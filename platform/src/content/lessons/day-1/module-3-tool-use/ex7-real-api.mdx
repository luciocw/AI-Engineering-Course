---
title: "Connecting Tools to Real APIs"
description: "Wire tool handlers to real HTTP APIs, handle errors from external services, and manage API keys securely."
day: "day-1"
module: "module-3-tool-use"
exercise: 7
difficulty: "intermediate"
estimatedMinutes: 25
isFree: true
tags: ["tools", "function-calling", "api-integration", "http", "error-handling", "api-keys"]
---

## What You'll Learn

- How to make HTTP calls inside tool handlers
- Error handling strategies for external services
- Managing API keys with environment variables
- Transforming API responses into LLM-friendly formats

## Key Concepts

### From Mock to Real

So far, our tool handlers have returned hardcoded data. Now we connect them to real APIs. The key principle: **your tool handler is the bridge between the LLM and the outside world**.

```typescript
// Before: mock handler
function getWeather(city: string): string {
  return JSON.stringify({ temp: 22, conditions: "Sunny" });
}

// After: real API call
async function getWeather(city: string): Promise<string> {
  const response = await fetch(
    `https://api.weatherapi.com/v1/current.json?key=${process.env.WEATHER_API_KEY}&q=${encodeURIComponent(city)}`
  );

  if (!response.ok) {
    return JSON.stringify({ error: `Weather API error: ${response.status}` });
  }

  const data = await response.json();
  return JSON.stringify({
    city: data.location.name,
    temp_c: data.current.temp_c,
    conditions: data.current.condition.text,
    humidity: data.current.humidity,
  });
}
```

### HTTP Calls in Tool Handlers

Use the built-in `fetch` API (available in Node.js 18+) for HTTP calls:

```typescript
async function callExternalApi(
  url: string,
  options?: RequestInit
): Promise<{ ok: boolean; data: any; error?: string }> {
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
      },
    });

    if (!response.ok) {
      return {
        ok: false,
        data: null,
        error: `HTTP ${response.status}: ${response.statusText}`,
      };
    }

    const data = await response.json();
    return { ok: true, data };
  } catch (error) {
    return {
      ok: false,
      data: null,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}
```

### Error Handling for External Services

External APIs fail. Your tool handlers must handle this gracefully. The goal: return a clear error message so the LLM can tell the user what happened.

```typescript
async function handleSearchTool(input: { query: string }): Promise<string> {
  const result = await callExternalApi(
    `https://api.example.com/search?q=${encodeURIComponent(input.query)}`,
    {
      headers: {
        Authorization: `Bearer ${process.env.SEARCH_API_KEY}`,
      },
    }
  );

  // Handle API errors gracefully
  if (!result.ok) {
    return JSON.stringify({
      error: "Search service is currently unavailable",
      details: result.error,
      suggestion: "Please try again in a moment or rephrase your query.",
    });
  }

  // Transform API response to what the LLM needs
  const results = result.data.items.map((item: any) => ({
    title: item.title,
    snippet: item.snippet,
    url: item.url,
  }));

  return JSON.stringify({ results, total: result.data.total });
}
```

### API Key Management

Never hardcode API keys. Use environment variables:

```typescript
// .env file (add to .gitignore!)
// WEATHER_API_KEY=your_key_here
// SEARCH_API_KEY=your_key_here

// Load with dotenv at app startup
import "dotenv/config";

// Access in your handlers
function getApiKey(name: string): string {
  const key = process.env[name];
  if (!key) {
    throw new Error(
      `Missing environment variable: ${name}. ` +
        `Add it to your .env file.`
    );
  }
  return key;
}

// Usage in a handler
async function handleWeather(input: { city: string }): Promise<string> {
  const apiKey = getApiKey("WEATHER_API_KEY");
  const url = `https://api.weatherapi.com/v1/current.json?key=${apiKey}&q=${encodeURIComponent(input.city)}`;

  const response = await fetch(url);
  // ... handle response
}
```

### Transforming API Responses

Raw API responses often contain far more data than the LLM needs. Filter and reshape them:

```typescript
// Raw API response (hundreds of fields)
const rawGitHubIssue = {
  id: 1234,
  number: 42,
  title: "Bug: login fails",
  body: "When I try to log in...",
  user: { login: "alice", id: 5678, avatar_url: "...", /* 20 more fields */ },
  labels: [{ name: "bug", color: "red", /* more fields */ }],
  state: "open",
  created_at: "2024-01-15T10:00:00Z",
  // ... 50 more fields
};

// Transformed for the LLM (only what matters)
function transformIssue(raw: any) {
  return {
    number: raw.number,
    title: raw.title,
    body: raw.body?.substring(0, 500), // truncate long bodies
    author: raw.user.login,
    labels: raw.labels.map((l: any) => l.name),
    state: raw.state,
    created: raw.created_at,
  };
}
```

### Complete Example: GitHub Issues Tool

```typescript
import Anthropic from "@anthropic-ai/sdk";
import "dotenv/config";

const client = new Anthropic();

const tools: Anthropic.Tool[] = [
  {
    name: "list_github_issues",
    description:
      "List recent issues from a GitHub repository. " +
      "Returns issue number, title, author, labels, and state. " +
      "Use when the user asks about bugs, issues, or tasks in a repo.",
    input_schema: {
      type: "object" as const,
      properties: {
        owner: {
          type: "string",
          description: "Repository owner (username or org), e.g. 'facebook'",
        },
        repo: {
          type: "string",
          description: "Repository name, e.g. 'react'",
        },
        state: {
          type: "string",
          enum: ["open", "closed", "all"],
          description: "Filter by issue state. Defaults to 'open'.",
        },
        limit: {
          type: "number",
          description: "Max issues to return (1-30, default 5)",
        },
      },
      required: ["owner", "repo"],
    },
  },
];

async function handleListIssues(input: {
  owner: string;
  repo: string;
  state?: string;
  limit?: number;
}): Promise<string> {
  const { owner, repo, state = "open", limit = 5 } = input;

  try {
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/issues?state=${state}&per_page=${limit}`,
      {
        headers: {
          Accept: "application/vnd.github.v3+json",
          // GitHub API works without auth for public repos
          // but has rate limits. Add token for higher limits:
          // Authorization: `token ${process.env.GITHUB_TOKEN}`,
        },
      }
    );

    if (!response.ok) {
      return JSON.stringify({
        error: `GitHub API returned ${response.status}`,
        hint: response.status === 404
          ? "Repository not found. Check the owner and repo name."
          : "Please try again later.",
      });
    }

    const issues = await response.json();
    const transformed = issues.map((issue: any) => ({
      number: issue.number,
      title: issue.title,
      author: issue.user?.login,
      labels: issue.labels?.map((l: any) => l.name),
      state: issue.state,
      created: issue.created_at,
    }));

    return JSON.stringify({ issues: transformed, total: transformed.length });
  } catch (error) {
    return JSON.stringify({
      error: "Failed to connect to GitHub",
      details: error instanceof Error ? error.message : "Network error",
    });
  }
}
```

## Common Mistakes

1. **Not encoding URL parameters** -- Always use `encodeURIComponent()` for user-provided values in URLs. A city like "New York" breaks without encoding.

2. **Exposing raw API errors** -- Don't pass raw error objects to the LLM. Transform them into human-readable messages with suggestions.

3. **Sending too much data back** -- A 50KB API response is wasteful as a tool result. Extract only the fields the LLM needs to answer the question.

4. **No timeout on HTTP calls** -- External APIs can hang. Use `AbortController` to set timeouts:

```typescript
const controller = new AbortController();
const timeout = setTimeout(() => controller.abort(), 10000); // 10s timeout
const response = await fetch(url, { signal: controller.signal });
clearTimeout(timeout);
```

5. **Hardcoding API keys in source code** -- Always use environment variables. Even in tutorials, build the habit early.

## Your Task

Build a tool that connects to a real public API (no API key required). Good options:
- **JSONPlaceholder** (`https://jsonplaceholder.typicode.com`) -- fake REST API for testing
- **Open-Meteo** (`https://api.open-meteo.com`) -- free weather API
- **PokeAPI** (`https://pokeapi.co/api/v2/`) -- Pokemon data

Create the tool definition, implement the handler with proper error handling, transform the API response to only include relevant fields, and wire it into the tool use loop. Handle network errors and non-200 responses gracefully.
